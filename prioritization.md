## Introduction

Several years ago I was running a project where we were developing a soluton for a client. The client wanted the software to
be delivered within a certain budget and time frame. Requirements were not yet finalized, and they were evolving as the 
project went on. I was working for the consultancy that had already committed to delivering the software within those stated 
constraints.

Sounds familiar? I think this situation is not different from what many suppliers of IT projects face.

We failed of course to deliver the software on time or within budget. But there were lessons I learned from that experience
which are general and should be applied regardless of methodology of development.

### Understanding Customer Priorities
A basic step is to understand what the customer's priorties are.

In this project that I mention above, the customer's highest priority was delivery on time and budget. Given those priorities, some of the
decisions we made were incorrect. We decided to build a very nice multi-tier architecture using technologies that none of us knew how 
to operate. But we liked the architecture as it sounded great, and so we went with it.
The result was enormous pain as we struggled to make basic things work. We just kept losing time as we struggled with the technology.

What we should have done is work with the technology we knew well, and deliver the functionality the customer wanted. We should have
sat down with the customer and explained to them that the only way to get the product delivered within their constraints was to
go with the simplest technology stack that we were all comfortable with.

Of course managing changing requirements is also a key factor to delivering on time, but here I want to point out that there are
other areas that often need to be managed as well. As programmers, we tend to have a natural inclination to learn new things, try out
new approaches and take risks. But when we work on customer projects, we need to put aside our own preferences and understand what
is necessary to get the project delivered. In particular, projects that are constrained in time and budget are not the right
vehicles for exploring new technologies.

### The Builder Analogy

I now like to think that we programmers need to think of ourselves as Builders, like the ones you employ to improve your home.
When you employ a Builder, you tell him or her what your requirements are, and the Builder gives you a timeframe and estimate. 
Ultimately will you hire a Builder who doesn't try to understand what you want, and then overspends resources and time to 
cost you twice the amount you had allocated for the home improvement? I wouldn't want such a Builder. And as programmers we need
to be like the Builder that you would want to hire. 
